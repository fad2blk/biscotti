#summary Frequently anticipated questions
#labels Featured

=Introduction=

===Is this library safe to use?===

Not really. This project is in the pre-alpha stage of development. Although there is a download available, I would encourage you to thoroughly test any part of this library that you are planning to use in a production environment.

===What was your motivation for building all this?===

Having somewhat of a background in data mining, I have always been fascinated by _cute_ and _efficient_ data structures.  I have been playing around with various third party collections libraries for Java since the days of Objectspace JGL. This library has been influenced by [http://recursionsw.com/Products/jgl.html JGL], [http://commons.apache.org/collections/ Apache Commons Collections], [http://trove.starlight-systems.com/ GNU Trove], and of course the [http://code.google.com/p/google-collections/ Google Collections], and the [http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html Java Collections Framework].

I designed this library from the ground up to have a well formed interface hierarchy matching (and in some cases improving on) that of the JDK. Further more this project faithfully adheres to the conventions set forth by the JDK and to a lesser extent by the Google Collections.

= Design =

===Why so much emphasis on sorted collections?===

This library isn't just a rehash of what is already out there. For the most part sorted data structures have generally been missing from most collections libraries, and not only for Java. For example I would be very interested to see any implementation of the [http://download.oracle.com/javase/6/docs/api/java/util/List.html List] interface which maintains the elements in sorted order, let alone provides fast random insertion and removal operations.

===Why do you need a sorted list? A [http://google-collections.googlecode.com/svn/trunk/javadoc/index.html?com/google/common/collect/TreeMultiset.html TreeMultiset] is already provided in the Google Collections.===

I've been asked this question several times. The idea that a `Multiset` (or `Bag`) can be substituted for a `List` is a misnomer. Without getting into mathematical abstractions, it is suffice to say that a `List` is the only data structure that provides explicit control over the order of the elements. For example you can explicitly query for the element located in the `i`_th_ position.

Incidentally a similar question was asked under one of the issues in the Google Collections regarding the implementation of a `UniqueList` (a list the rejects duplicate elements) versus a `SortedSet`.

===If you build on Java 6 and try to match the interface hierarchy of the JDK, why do you have a [http://biscotti.googlecode.com/svn/trunk/javadoc/index.html?com/googlecode/biscotti/collect/SortedList.html SortedList]<br>and not a `NavigableList` with methods analogous to `NavigableSet`?===

Good catch. Simply put the `SortedList` interface was more than enough to demonstrate the concrete [http://biscotti.googlecode.com/svn/trunk/javadoc/index.html?com/googlecode/biscotti/collect/TreeList.html TreeList] implementation. In the future I plan to create a`NavigableList` interface and have `TreeList` to implement it.

===Besides synchronized wrappers in the [http://biscotti.googlecode.com/svn/trunk/javadoc/index.html?com/googlecode/biscotti/collect/Collections3.html Collections3] class, you don't have any thread-safe, let alone<br>concurrent implementations of your collections, what gives?===

Good question. The only _tree_-based locking implementations which I am aware of choke under concurrent access. Their performance degrades linearly with each new concurrent user, and they don't perform significantly better than the provided synchronized wrappers which act like a global lock.

On the other hand, there are several [http://en.wikipedia.org/wiki/Skip_list Skip List] locking and lock-free concurrent algorithms which are remarkably fast, and are fairly strait forward to implement. I've been working on implementing [http://www.cs.brown.edu/~levyossi/Pubs/LazySkipList.pdf A Simple Optimistic Skip-List Algorithm]. The first implementation will probably come in the form of a `ConcurrentSkipQueue`.

===Didn't [http://en.wikipedia.org/wiki/Doug_Lea Doug Lea] already implement a [http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListSet.html ConcurrentSkipListSet] for Java 6?===

Yes. In fact the algorithm implemented by Doug Lea is lock-free and is the fastest concurrent skip-list based algorithm that I am aware of. Having said that, besides being extremely complicated, OpenJDK was released under the GNU General Public License (GPL). Even if it was possible to modify his algorithm for the purposes of this project, the GPL License is completely incompatible with the Apache License 2.0 under which this project was released.

===Why do you provide a [http://biscotti.googlecode.com/svn/trunk/javadoc/index.html?com/googlecode/biscotti/base/CloneNotSupportedException.html CloneNotSupportedException]? One is already provided in Java, and you don't<br>even use it in your Collections.===

Another good catch. My collections are cloneable for the sake of consistency, but this wasn't always so. For the most part this explanation is part of a much bigger rant that doesn't belong here in this FAQ. Having said that, the [http://download.oracle.com/javase/6/docs/api/java/lang/CloneNotSupportedException.html CloneNotSupportedException] in the JDK is not a runtime exception. If you extend a class which implements the `Cloneable` the only way the child class can throw a `CloneNotSupportedException` is if the `clone()` method of the parent class throws it. This is a catch-22 situation, since the parent class almost never throws it, because it is in fact designed to be cloned.

For many other reasons, cloning is horribly broken in Java. Don't take my word for it. Here is what [http://en.wikipedia.org/wiki/Joshua_Bloch Joshua Bloch] had to say [http://www.artima.com/intv/bloch13.html about it].

The least I could do is provide an analogous runtime exception.